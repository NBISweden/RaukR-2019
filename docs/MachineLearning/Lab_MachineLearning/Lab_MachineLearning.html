<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Nikolay Oskolkov" />


<title>Machine Learning in R</title>

<script src="Lab_MachineLearning_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="Lab_MachineLearning_files/bootstrap-3.3.5/css/united.min.css" rel="stylesheet" />
<script src="Lab_MachineLearning_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="Lab_MachineLearning_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="Lab_MachineLearning_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="Lab_MachineLearning_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="Lab_MachineLearning_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="Lab_MachineLearning_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="Lab_MachineLearning_files/navigation-1.1/tabsets.js"></script>
<link href="Lab_MachineLearning_files/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="Lab_MachineLearning_files/highlightjs-9.12.0/highlight.js"></script>
<link href="Lab_MachineLearning_files/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="Lab_MachineLearning_files/pagedtable-1.1/js/pagedtable.js"></script>
<link href="Lab_MachineLearning_files/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="Lab_MachineLearning_files/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<link id="font-awesome-1-attachment" rel="attachment" href="Lab_MachineLearning_files/font-awesome-5.1.0/fonts/fontawesome-webfont.ttf"/>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="assets/lab.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Machine Learning in R</h1>
<h3 class="subtitle">RaukR 2019 • Advanced R for Bioinformatics</h3>
<h4 class="author">Nikolay Oskolkov</h4>

</div>


<p><link href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro:300,400,600|Ubuntu+Mono&amp;subset=latin-ext" rel="stylesheet"></p>
<p><img src="assets/logo.svg" alt="logo_raukr" class="trlogo"></p>
<!-- ------------ Only edit title, subtitle & author above this ------------ -->
<br>
<div class="abstract spaced">
<p>In this tutorial, we talk about what Machine Learning does and why to use it. We discuss Supervised and Unsupervised as well as Linear vs. Non-Linear algorithms. As an example of model evaluation we will concentrate on K-fold cros-validation and compare most important Machine Learning algorithms. Finally, we will briefly cover Artificial Neural Networks (ANN) and check how it compares to traditional Machine Learning algorithms.</p>
</div>
<p><br></p>
<div id="what-is-machine-learning" class="section level1">
<h1><span class="header-section-number">1</span> What is Machine Learning?</h1>
<p>In this section we will brifly describe what Machine Learning (ML) is, why to use it in Computational Biology, and how it works. In order to introduce principals of ML we will start with a few basic definitions.</p>
<ul>
<li>Machine Learning is a powerful technique that allows to map input X to output Y as</li>
</ul>
<p><span class="math display">\[Y = f ( X )\]</span></p>
<p>without necessarily knowing the functional form of f. Machine Learning provides two major benifits that have a wide application in e.g. Biomedicine:</p>
<ol style="list-style-type: decimal">
<li><strong>Prediction</strong>: Biomedicine needs precise classification of disease sub-types in order to make correct treatment prescription</li>
<li><strong>Feature Selection</strong>: Biomedicine needs biomarkers for understanding mechanisms of a disease</li>
</ol>
<p>Beyond biomedical applications, ML is widely used in business, industry, physics, astronomy, and even in psychology, archeology etc. Internet is heavily based on Artificial Intellegence (AI), Deep Learning and Machine Learning and Google, Amazon, Facebook and Microsoft are world leading drivers and promoters of AI.</p>
<ul>
<li><p>Machine Learning can be categorized into:</p>
<ul>
<li><strong>Parametric</strong>: assumtion on f(X), often linear, easy to learn, fast, little data needed, poor prediction (example: Linear and Logistic Regression)</li>
<li><strong>Non-Parametric</strong>: assumtion free, difficult to train, slow, needs a lot of data, higher prediction power (example: Random Forest, LASSO)</li>
</ul></li>
<li><p>Machine Learning by default involves five basic steps:</p></li>
</ul>
<ol style="list-style-type: decimal">
<li>Split data set into <strong>train</strong>, <strong>validation</strong> and <strong>test</strong> subsets.</li>
<li>Fit the model in the train subset.</li>
<li>Validate your model in the validation suset via calculating the error of prediction.</li>
<li>Repeat steps 1-3 many times and find <strong>hyperparameters</strong> of your model which minimize the error of reproducibility from 3.</li>
<li>Test the accuracy of the optimized model on the test subset for final evaluation.</li>
</ol>
<p>The steps 1-4 are called <strong>cross-validation (CV)</strong>. CV is a common technique for finding optimal hyperparameters in Machine Learning.</p>
<ul>
<li>Finally, Machine Learning is divided into:
<ul>
<li><strong>Supervised</strong>: data are labelled and Y is predicted from X as Y=f(X)</li>
<li><strong>Unsupervised</strong>: only X is present and we infer hidden patterns in X</li>
</ul></li>
</ul>
</div>
<div id="how-does-machine-learning-work" class="section level1">
<h1><span class="header-section-number">2</span> How Does Machine Learning Work?</h1>
<p>Let us demonstrate how Machine Lerning works using a toy example. Let us simulate a noisy linear relation of two variables x and y with a known coefficient (true beta):</p>
<pre class="r"><code>set.seed(12345)

N&lt;-100
true_beta&lt;-2

x&lt;-rnorm(N)
y&lt;-true_beta*x+rnorm(N)

df&lt;-data.frame(x,y)
head(df,10)

plot(y~x,data=df)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.5855288","2":"1.3949830","_rn_":"1"},{"1":"0.7094660","2":"0.2627087","_rn_":"2"},{"1":"-0.1093033","2":"0.2038119","_rn_":"3"},{"1":"-0.4534972","2":"-2.2317496","_rn_":"4"},{"1":"0.6058875","2":"1.3528592","_rn_":"5"},{"1":"-1.8179560","2":"-4.1719599","_rn_":"6"},{"1":"0.6300986","2":"0.9485910","_rn_":"7"},{"1":"-0.2761841","2":"1.0037414","_rn_":"8"},{"1":"-0.2841597","2":"-1.0163528","_rn_":"9"},{"1":"-0.9193220","2":"-1.5175205","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-3-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>Let us randomly split our sample into training (70% of sample) and test (30% of sample) data sets. Further, let us display the training (blue points) and test (red points) sets on the linear regression plot:</p>
<pre class="r"><code>set.seed(123)
train&lt;-df[sample(1:dim(df)[1],0.7*dim(df)[1]),]
test&lt;-df[!rownames(df)%in%rownames(train),]

df$color[rownames(df)%in%rownames(train)]&lt;-&quot;blue&quot;
df$color[rownames(df)%in%rownames(test)]&lt;-&quot;red&quot;
head(df,10)

plot(y~x,data=df,col=df$color)
legend(&quot;topleft&quot;,c(&quot;Train&quot;,&quot;Test&quot;),fill=c(&quot;blue&quot;,&quot;red&quot;),inset=0.02)
abline(lm(y~x,data=train),col=&quot;blue&quot;)
abline(lm(y~x,data=test),col=&quot;red&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["color"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"0.5855288","2":"1.3949830","3":"red","_rn_":"1"},{"1":"0.7094660","2":"0.2627087","3":"red","_rn_":"2"},{"1":"-0.1093033","2":"0.2038119","3":"red","_rn_":"3"},{"1":"-0.4534972","2":"-2.2317496","3":"blue","_rn_":"4"},{"1":"0.6058875","2":"1.3528592","3":"blue","_rn_":"5"},{"1":"-1.8179560","2":"-4.1719599","3":"blue","_rn_":"6"},{"1":"0.6300986","2":"0.9485910","3":"blue","_rn_":"7"},{"1":"-0.2761841","2":"1.0037414","3":"blue","_rn_":"8"},{"1":"-0.2841597","2":"-1.0163528","3":"blue","_rn_":"9"},{"1":"-0.9193220","2":"-1.5175205","3":"red","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-4-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>The blue line is the linear fit obtained on the training set while the red line corresponds to the fit on the test data set. <strong>We are not supposed to fit the model on the test data set</strong> but we show the red line for comparision in order to demonstrate that the lines do not coinside which means that the model trained on the training data set will not fit perfectly the test data. This is how it is in real biology where there is always substantial amount of noise and technical variation.</p>
<p>Let us now again fit the linear regression model (train the model) on the training data set and try to use this model in order to predict (validate, evaluate) the slope on the test data set. For this purpose we will plot predicted vs. real y values in the test data set and calculate how much of the variance in y we can capture with our model:</p>
<pre class="r"><code>summary(lm(y~x,data=train))
test_predicted&lt;-as.numeric(predict(lm(y~x,data=train),newdata=test))
plot(test$y~test_predicted,ylab=&quot;True y&quot;,xlab=&quot;Predicted y&quot;)
abline(lm(test$y~test_predicted))
summary(lm(test$y~test_predicted))</code></pre>
<pre><code>## 
## Call:
## lm(formula = y ~ x, data = train)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -2.25403 -0.53634  0.06931  0.65362  2.31960 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.03481    0.12024   0.289    0.773    
## x            2.15630    0.10628  20.289   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.9991 on 68 degrees of freedom
## Multiple R-squared:  0.8582, Adjusted R-squared:  0.8561 
## F-statistic: 411.7 on 1 and 68 DF,  p-value: &lt; 2.2e-16
## 
## 
## Call:
## lm(formula = test$y ~ test_predicted)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1.80597 -0.78005  0.07636  0.52330  2.61924 
## 
## Coefficients:
##                Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)     0.02058    0.21588   0.095    0.925    
## test_predicted  0.89953    0.08678  10.366 4.33e-11 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.053 on 28 degrees of freedom
## Multiple R-squared:  0.7933, Adjusted R-squared:  0.7859 
## F-statistic: 107.4 on 1 and 28 DF,  p-value: 4.329e-11</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-5-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>Thus, our model trained on the training data set explains approximately 86% of variation in the training daat set and 76% of variation in the test data which can be seen from the reported above adjusted R squared statistics. In theory, the model can explain 100% of variation in the training data set (it does not in our case because we used random noise to model relationship between the variables), but this is not interesting for us, this is the case of so-called “over-fitting”, we will come back to this later. More interesting for us is how much of the variation the model explains in the unseen test data, this will be an ultimate objective criterion of how successful our model is. So in our case the model is not ideal but not too bad. Note that in order to establish a confidence interval for that statistic we need to randomly split the data into training and test subsets many times and calculate the distribution of adjusted R squared.</p>
</div>
<div id="the-curse-of-dimensionality" class="section level1">
<h1><span class="header-section-number">3</span> The Curse of Dimensionality</h1>
<p>Above we described a simplified Machine Learning design, i.e. a minimal training and validation one must always do. A more comprehensive Machine Learning analysis can be achieved by fine-tuning hyperparameters which almost all models have. The Machine Learning toy example from the previous section did not involve hyperparameters due to its simplicity such as only two variables were regressed against each other, Gaussian distribution was assumed by default. We can make a more complicated, i.e. closer to real world model and demonstrate how we can use cross-validation to adjust additional (hyper-)parameters.</p>
<p>For this purpose we need to define a hyperparameter for our model. This could be for example <strong>the number of variables to adjust the main variable x of interest for</strong>. Let us assume that y is a phenotype of interest (disease, speciation, cell state etc.) and x is the main explanatory variable of interest (genotype, methylation status, gene expression etc.) whose effect we would like to study. Suppose the relation y vs. x is confounded by other factors of unwanted variation (batch, ethnicity, age etc.) which we will call PC1, PC2, …, PC10 assuming that the unwanted variation can be factorized via e.g. PCA and adjusted for in the y vs. x linear regression model. Let us simulate the PCs which are correlated with y slightly weaker (smaller effect size) than x is correlated with y.</p>
<pre class="r"><code>set.seed(1)
for(i in 1:10)
{
  df[,paste0(&quot;PC&quot;,i)]&lt;-1*(1-i/10)*y+rnorm(N)
}
head(df,10)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["color"],"name":[3],"type":["chr"],"align":["left"]},{"label":["PC1"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["PC2"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["PC3"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["PC4"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["PC5"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["PC6"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["PC7"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["PC8"],"name":[11],"type":["dbl"],"align":["right"]},{"label":["PC9"],"name":[12],"type":["dbl"],"align":["right"]},{"label":["PC10"],"name":[13],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.5855288","2":"1.3949830","3":"red","4":"0.6290309","5":"0.4956198","6":"1.3858900","7":"1.7306635","8":"1.7719325","9":"0.63529634","10":"0.07742793","11":"-0.4285716","12":"-0.9474105","13":"-1.5414026","_rn_":"1"},{"1":"0.7094660","2":"0.2627087","3":"red","4":"0.4200812","5":"0.2522828","6":"1.8727694","7":"-0.8896729","8":"2.0270091","9":"-0.19178516","10":"1.58123715","11":"2.0241138","12":"-1.7998121","13":"0.1943211","_rn_":"2"},{"1":"-0.1093033","2":"0.2038119","3":"red","4":"-0.6521979","5":"-0.7478721","6":"1.7292568","7":"2.0936245","8":"-0.5010914","9":"-1.10171748","10":"0.58945128","11":"-0.0492363","12":"1.0156630","13":"0.2644225","_rn_":"3"},{"1":"-0.4534972","2":"-2.2317496","3":"blue","4":"-0.4132938","5":"-1.6273709","6":"-1.8931325","7":"-1.7226819","8":"-1.5067426","9":"-0.88140715","10":"-0.12733353","11":"-0.4603672","12":"-0.2350367","13":"-1.1187352","_rn_":"4"},{"1":"0.6058875","2":"1.3528592","3":"blue","4":"1.5470811","5":"0.4277027","6":"-1.3382341","7":"2.4658608","8":"0.2602076","9":"1.53274473","10":"0.26918441","11":"-0.8528851","12":"-0.4643425","13":"0.6509530","_rn_":"5"},{"1":"-1.8179560","2":"-4.1719599","3":"blue","4":"-4.5752323","5":"-1.5702807","6":"-0.4227104","7":"-0.9909633","8":"-2.4616374","9":"-0.07481652","10":"-2.38832183","11":"-2.1785221","12":"-0.5951440","13":"-1.0329002","_rn_":"6"},{"1":"0.6300986","2":"0.9485910","3":"blue","4":"1.3411610","5":"1.4755803","6":"1.3310799","7":"0.6521203","8":"0.1076646","9":"-0.99327486","10":"-1.21204985","11":"-1.3334376","12":"-0.3311222","13":"0.6592015","_rn_":"7"},{"1":"-0.2761841","2":"1.0037414","3":"blue","4":"1.6416920","5":"1.7131674","6":"1.2439463","7":"1.1694658","8":"0.2061933","9":"0.15188564","10":"0.07773679","11":"-0.2212199","12":"1.0970329","13":"0.2378294","_rn_":"8"},{"1":"-0.2841597","2":"-1.0163528","3":"blue","4":"-0.3389361","5":"-0.4288969","6":"-0.7248465","7":"-1.6343601","8":"0.9336440","9":"0.75288342","10":"1.69681339","11":"1.1576539","12":"0.6260254","13":"0.7152759","_rn_":"9"},{"1":"-0.9193220","2":"-1.5175205","3":"red","4":"-1.6711568","5":"0.4681597","6":"-0.5521559","7":"-0.5875058","8":"-1.4562985","9":"-1.72123053","10":"-0.23355232","11":"1.4502908","12":"-1.8783826","13":"-0.9384830","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Please note the coefficient 1 in front of (1-i/10). This implies, PC1 will be correlated with y with coefficient 0.9, PC2 wil be correlated with 0.8 etc. down to PC10 which is not correlated with y at all, we model PC10 by just a white noise. Now let us monitor the strength of correlation y vs. x as we adjust the model for more and more PCs.</p>
<pre class="r"><code>summary(lm(y~x,data=df))
summary(lm(y~x+PC1,data=df))
summary(lm(y~x+PC1+PC2,data=df))
summary(lm(y~x+PC1+PC2+PC3+PC4+PC5+PC6+PC7+PC8+PC9+PC10,data=df))
effect&lt;-vector()
effect&lt;-append(effect,2)
adj_r_squared&lt;-vector()
adj_r_squared&lt;-append(adj_r_squared,summary(lm(y~x,data=df))$adj.r.squared)
for(i in 1:10)
{
  formula&lt;-as.formula(paste0(&quot;y~x+&quot;,paste0(&quot;PC&quot;,seq(1:i),collapse=&quot;+&quot;)))
  effect&lt;-append(effect,summary(lm(formula,data=df))$coefficients[2,1])
  adj_r_squared&lt;-append(adj_r_squared,summary(lm(formula,data=df))$adj.r.squared)
}
plot(effect~seq(from=0,to=10,by=1),type=&#39;o&#39;,xlab=&quot;PRINCIPAL COMPONENTS&quot;,ylab=&quot;EFFECT&quot;)
plot(adj_r_squared~seq(from=0,to=10,by=1),type=&#39;o&#39;,xlab=&quot;PRINCIPAL COMPONENTS&quot;,ylab=&quot;VARIANCE EXPLAINED BY MODEL&quot;)</code></pre>
<pre><code>## 
## Call:
## lm(formula = y ~ x, data = df)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -2.20347 -0.60278 -0.01114  0.61898  2.60970 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.02205    0.10353   0.213    0.832    
## x            2.09454    0.09114  22.982   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.011 on 98 degrees of freedom
## Multiple R-squared:  0.8435, Adjusted R-squared:  0.8419 
## F-statistic: 528.2 on 1 and 98 DF,  p-value: &lt; 2.2e-16
## 
## 
## Call:
## lm(formula = y ~ x + PC1, data = df)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1.54485 -0.49785 -0.05715  0.41808  2.12392 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -0.05986    0.07752  -0.772    0.442    
## x            1.07261    0.13269   8.083 1.78e-12 ***
## PC1          0.56263    0.06281   8.958 2.38e-14 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.7517 on 97 degrees of freedom
## Multiple R-squared:  0.9143, Adjusted R-squared:  0.9126 
## F-statistic: 517.7 on 2 and 97 DF,  p-value: &lt; 2.2e-16
## 
## 
## Call:
## lm(formula = y ~ x + PC1 + PC2, data = df)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1.24744 -0.44379 -0.01225  0.36788  1.62660 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -0.04641    0.06166  -0.753    0.453    
## x            0.88065    0.10849   8.118 1.60e-12 ***
## PC1          0.35675    0.05684   6.276 1.00e-08 ***
## PC2          0.39744    0.05243   7.581 2.16e-11 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.5976 on 96 degrees of freedom
## Multiple R-squared:  0.9464, Adjusted R-squared:  0.9447 
## F-statistic: 565.3 on 3 and 96 DF,  p-value: &lt; 2.2e-16
## 
## 
## Call:
## lm(formula = y ~ x + PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + 
##     PC8 + PC9 + PC10, data = df)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.88558 -0.41183 -0.00967  0.30393  1.42820 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -0.03481    0.05217  -0.667  0.50633    
## x            0.55269    0.10805   5.115 1.82e-06 ***
## PC1          0.26169    0.05119   5.112 1.84e-06 ***
## PC2          0.31127    0.04773   6.521 4.26e-09 ***
## PC3          0.11629    0.05098   2.281  0.02496 *  
## PC4          0.20586    0.05142   4.003  0.00013 ***
## PC5          0.02275    0.04476   0.508  0.61251    
## PC6          0.20339    0.05053   4.025  0.00012 ***
## PC7          0.13035    0.05241   2.487  0.01476 *  
## PC8          0.04039    0.04749   0.851  0.39733    
## PC9         -0.06749    0.04944  -1.365  0.17573    
## PC10         0.03254    0.05127   0.635  0.52735    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.4999 on 88 degrees of freedom
## Multiple R-squared:  0.9656, Adjusted R-squared:  0.9613 
## F-statistic: 224.8 on 11 and 88 DF,  p-value: &lt; 2.2e-16</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-7-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-7-2.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>This is really striking! The unadjusted model gives us almost the true effect size 2 while when we adjust for PC1, it drops drammatically down to 1.07. If we adjust for PC1 and PC2 it becomes 0.88 and so on down to 0.55 when adjusting for all 10 PCs. And now look at the adjusted R squared statistic demonstrating how much of variation in y is explained by the explanatory variables. It is increasing!</p>
<p>What does it mean? It means that we are fiting the data better and better (explain more and more variation in y) by adding more explanatory variables into the model due to the combined effect of all the variables. Simultaneously, the capasity of our model to discover true x vs. y effect of correlation is rapidly decreasing when we go to high-dimensional space. In other words, prediction of our model is increasing but individual effects are no longer true although the ranking variables by their importance is still true, look at the effect sizes and see that x is still the most important. This is known as “the curse of dimensionality” and is one of the major chellanges in Data Science. The toy example above emphizes the fact that Machine Learning is preddominantly multivariate, i.e. the goal is to get the best <strong>prediction and feature selection</strong>, however individual effects and biological meaning of each variable gets duluted and sucrifised for the beter multivariate model performance.</p>
<p>We know that both the PCs and x are slightly correlated with y, thus PCs are also correlated with x, therefore we have multiple correlated variables in the linear regression model, this is the case of multi-collinearity which is not bad by itself but breaks the assumtions of Maximum Likelihood principle which lies behind the linear regression model.</p>
<p>As a final shot, let us look at the effect of x and adjusted R squared when only PC10 is a covariate, remember PC10 was a pure white noise.</p>
<pre class="r"><code>summary(lm(y~x+PC10,data=df))</code></pre>
<pre><code>## 
## Call:
## lm(formula = y ~ x + PC10, data = df)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -2.36000 -0.60286  0.03532  0.53669  2.47187 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.02501    0.10233   0.244   0.8075    
## x            2.07959    0.09045  22.992   &lt;2e-16 ***
## PC10         0.17423    0.09559   1.823   0.0714 .  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.9991 on 97 degrees of freedom
## Multiple R-squared:  0.8487, Adjusted R-squared:  0.8456 
## F-statistic:   272 on 2 and 97 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Correct! The effect size of x and adjusted R squared are very similar to the ones from the unadjusted model. Thus, less multi-collinearity brings more correct individual effect size estimates and avoids inflation of adjusted R squared statistic.</p>
<p>What if we increase the strength of covariation between y and PCs from 1 to 2 and 3, i.e. make PCs covary with y equally or even stronger than x?</p>
<pre class="r"><code>effect_master&lt;-list()
for(k in 1:3)
{
  for(i in 1:10)
  {
    df[,paste0(&quot;PC&quot;,i)]&lt;-k*(1-i/10)*y+rnorm(N)
  }

  effect&lt;-vector()
  effect&lt;-append(effect,2)
  for(i in 1:10)
  {
    formula&lt;-as.formula(paste0(&quot;y~x+&quot;,paste0(&quot;PC&quot;,seq(1:i),collapse=&quot;+&quot;)))
    effect&lt;-append(effect,summary(lm(formula,data=df))$coefficients[2,1])
  }
  effect_master[[k]]&lt;-effect
}
plot(effect_master[[1]]~seq(from=0,to=10,by=1),type=&#39;o&#39;,xlab=&quot;PRINCIPAL COMPONENTS&quot;,ylab=&quot;EFFECT&quot;,xlim=c(0,10),ylim=c(0,2),col=&quot;blue&quot;,main=&quot;Effect of x vs. y at different covariation between y and PCs&quot;)
points(effect_master[[2]]~seq(from=0,to=10,by=1),col=&quot;green&quot;)
lines(effect_master[[2]]~seq(from=0,to=10,by=1),col=&quot;green&quot;)
points(effect_master[[3]]~seq(from=0,to=10,by=1),col=&quot;red&quot;)
lines(effect_master[[3]]~seq(from=0,to=10,by=1),col=&quot;red&quot;)
legend(&quot;topright&quot;,c(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;),title=&quot;Covariation&quot;,fill=c(&quot;blue&quot;,&quot;green&quot;,&quot;red&quot;),inset=0.02)</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-9-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>Again, very strikingly, the effect of x reaches zero when increasing the strength of covariation between y and the PCs. This implies that the PCs are more important variables for explaining variation in y so the rank and effect of variable x is becoming negligible.</p>
</div>
<div id="how-does-cross-validation-work" class="section level1">
<h1><span class="header-section-number">4</span> How Does Cross-Validation Work?</h1>
<p>Now let us ask a question: how many PCs should we include into our model, are they all equally informative for predicting the relation y vs. x? Thus the number of PCs to include into the model becomes a hyperparameter which we should somehow tune. Another valid question to ask would be: why not to include all 10 PCs? The reason we do not want to do it is because our model will loose its generalizibility, i.e. a lot of fitting parameters will make the model work best in one particular data set but not in another. Our goal is to figure out a balance between the goodness of fit and the minimal number of fitting parameters required, this is known as <strong>Bias vs. Variance</strong> tradeoff in Machine Learning.</p>
<p>The optimal number of PCs can be found via <strong>cross-validation (CV)</strong>, a procedure which minimizes the error of reproducibility of the fit across multiple sub-samples drawn from the data. In this way we produce the most generalizable model which very little depends on a particular training data set.</p>
<p>To demonstrate how cross-validation works, let us randomly assign 60% of the data to training set, 10% to validation set and 30% to test set. Further, let us display the training (blue points), validation (red points) and test (green points) sets on the linear regression plot:</p>
<pre class="r"><code>set.seed(1234)
train&lt;-df[sample(1:dim(df)[1],0.6*dim(df)[1]),]
validate_and_test&lt;-df[!rownames(df)%in%rownames(train),]
validate&lt;-validate_and_test[sample(1:dim(validate_and_test)[1],0.25*dim(validate_and_test)[1]),]
test&lt;-validate_and_test[!rownames(validate_and_test)%in%rownames(validate),]

df$color[rownames(df)%in%rownames(train)]&lt;-&quot;blue&quot;
df$color[rownames(df)%in%rownames(validate)]&lt;-&quot;red&quot;
df$color[rownames(df)%in%rownames(test)]&lt;-&quot;green&quot;
plot(y~x,data=df,col=df$color)
legend(&quot;topleft&quot;,c(&quot;Train&quot;,&quot;Validate&quot;,&quot;Test&quot;),fill=c(&quot;blue&quot;,&quot;red&quot;,&quot;green&quot;),inset=0.02)
abline(lm(y~x,data=train),col=&quot;blue&quot;)
abline(lm(y~x,data=validate),col=&quot;red&quot;)</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-10-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>Recall that previously we had just training and test subsamples. Why do we need one additional (validation) subsample? We need the validation subsample in order to tune the hyperparameter of the model, this is a part of training of the model. The validation subsample should not have anything to do with the test subsample, the latter will be used for an ultimate evaluation of the model while the former will participate in the training cross-validation procedure.</p>
<p>Let us now fit the linear regression model in the training set and validate the error (root mean squared difference between predicted y from the trained model for the validation set and the real y in the validation set) in the validation data set:</p>
<pre class="r"><code>set.seed(1)

train_and_validate&lt;-df[sample(1:dim(df)[1],0.7*dim(df)[1]),]
test&lt;-df[!rownames(df)%in%rownames(train_and_validate),]

N_cv&lt;-100
error&lt;-vector()

error_null&lt;-vector()
for(j in 1:N_cv)
{
  train&lt;-train_and_validate[sample(1:dim(train_and_validate)[1],(6/7)*dim(train_and_validate)[1]),]
  validate&lt;-train_and_validate[!rownames(train_and_validate)%in%rownames(train),]
  error_null&lt;-append(error_null,sqrt(sum((predict(lm(y~x,data=train),newdata=validate)-validate$y)^2)/dim(validate)[1]))
}
error&lt;-append(error,mean(error_null))

for(j in 1:10)
{
  error_at_pc&lt;-vector()
  formula&lt;-as.formula(paste0(&quot;y~x+&quot;,paste0(&quot;PC&quot;,seq(1:j),collapse=&quot;+&quot;)))
  for(i in 1:N_cv)
  {
    train&lt;-train_and_validate[sample(1:dim(train_and_validate)[1],(6/7)*dim(train_and_validate)[1]),]
    validate&lt;-train_and_validate[!rownames(train_and_validate)%in%rownames(train),]
    error_at_pc&lt;-append(error_at_pc,sqrt(sum((predict(lm(formula,data=train),newdata=validate)-validate$y)^2)/dim(validate)[1]))
  }
  error&lt;-append(error,mean(error_at_pc))
}
plot(error~seq(from=0,to=10,by=1),type=&#39;o&#39;,xlab=&quot;PRINCIPAL COMPONENTS&quot;,ylab=&quot;RMSE&quot;)</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/CV-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>Looks like the error drops drammatically when adding PC1 and PC2 and after that does not change much. We can conclude that the most generalizable model which also gives a fair goodness of fit is the one adjusted for two first PCs, i.e. “y~x+PC1+PC2”. Let us perform the final evaluation of the optimized/trained model on the test data set and report the final accuracy (adjusted R squared of the model):</p>
<pre class="r"><code>summary(lm(predict(lm(y~x+PC1+PC2,data=df),newdata=test)~test$y))</code></pre>
<pre><code>## 
## Call:
## lm(formula = predict(lm(y ~ x + PC1 + PC2, data = df), newdata = test) ~ 
##     test$y)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.48101 -0.09220 -0.02343  0.20324  0.48982 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.02482    0.05025   0.494    0.625    
## test$y       1.00612    0.02116  47.554   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.265 on 28 degrees of freedom
## Multiple R-squared:  0.9878, Adjusted R-squared:  0.9873 
## F-statistic:  2261 on 1 and 28 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Therefore the model explains over 90% of variation on the unseen test data set which is excellent.</p>
<p>Let us see what cross-validation gives us depending on the strength of covariation of y with PCs:</p>
<pre class="r"><code>error_master&lt;-list()
for(k in 1:3)
{
  for(i in 1:10)
  {
    df[,paste0(&quot;PC&quot;,i)]&lt;-k*(1-i/10)*y+rnorm(N)
  }

  set.seed(123)

  train_and_validate&lt;-df[sample(1:dim(df)[1],0.7*dim(df)[1]),]
  test&lt;-df[!rownames(df)%in%rownames(train_and_validate),]

  N_cv&lt;-100
  error&lt;-vector()

  error_null&lt;-vector()
  for(j in 1:N_cv)
  {
    train&lt;-train_and_validate[sample(1:dim(train_and_validate)[1],(6/7)*dim(train_and_validate)[1]),]
    validate&lt;-train_and_validate[!rownames(train_and_validate)%in%rownames(train),]
    error_null&lt;-append(error_null,sqrt(sum((predict(lm(y~x,data=train),newdata=validate)-validate$y)^2)/dim(validate)[1]))
  }
  error&lt;-append(error,mean(error_null))

  for(j in 1:10)
  {
    error_at_pc&lt;-vector()
    formula&lt;-as.formula(paste0(&quot;y~x+&quot;,paste0(&quot;PC&quot;,seq(1:j),collapse=&quot;+&quot;)))
    for(i in 1:N_cv)
    {
      train&lt;-train_and_validate[sample(1:dim(train_and_validate)[1],(6/7)*dim(train_and_validate)[1]),]
      validate&lt;-train_and_validate[!rownames(train_and_validate)%in%rownames(train),]
      error_at_pc&lt;-append(error_at_pc,sqrt(sum((predict(lm(formula,data=train),newdata=validate)-validate$y)^2)/dim(validate)[1]))
    }
    error&lt;-append(error,mean(error_at_pc))
  }
  error_master[[k]]&lt;-error
}
plot(error_master[[1]]~seq(from=0,to=10,by=1),type=&#39;o&#39;,xlab=&quot;PRINCIPAL COMPONENTS&quot;,ylab=&quot;RMSE&quot;,col=&quot;blue&quot;,main=&quot;RMSE of cross-validation at different covariation between y and PCs&quot;,xlim=c(0,10),ylim=c(0.2,1))
points(error_master[[2]]~seq(from=0,to=10,by=1),col=&quot;green&quot;)
lines(error_master[[2]]~seq(from=0,to=10,by=1),col=&quot;green&quot;)
points(error_master[[3]]~seq(from=0,to=10,by=1),col=&quot;red&quot;)
lines(error_master[[3]]~seq(from=0,to=10,by=1),col=&quot;red&quot;)
legend(&quot;topright&quot;,c(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;),title=&quot;Covariation&quot;,fill=c(&quot;blue&quot;,&quot;green&quot;,&quot;red&quot;),inset=0.02)</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/CV%20in%20High%20Dimensions-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>The main conclusion we can draw here is that the higher is the correlation between y and the PCs the more abruptly drops the error of reproducibility. I.e. for strong correlation between y and the PCs it is becoming very important to adjust the model for the PCs (i.e. the PCs are more important features than x for explaining variation in y), while with a moderate correlation this adjustment is not extremely important.</p>
</div>
<div id="comparing-machine-learning-methods" class="section level1">
<h1><span class="header-section-number">5</span> Comparing Machine Learning Methods</h1>
<p>Now let us do Rock-n-Roll and move to real hard-core Machine Learning. When introducing main concepts and developing basic understanding of Machine Learning in the previous sectionswe were dealing with so-called <strong>Regression</strong> Machine Learning using a linear method which was Linear Regressor (same as Linear Regression Model) because our phenotype of interest y was a continuous variable. Now we will be talking about <strong>Classification</strong> problem where we have a categotical (or even binary) phenotype of interest, i.e. sick-healthy, lean-overweight-obese, small-medium-large etc. We will be using the classic Pima Indians Diabetes data set which contains a few hudred individuals with and without diabetes and 8 explanatory variables (predictors) for making prediction about disease status of an individual.</p>
<pre class="r"><code>library(&quot;mlbench&quot;)
data(PimaIndiansDiabetes2)
head(PimaIndiansDiabetes2,10)
dim(PimaIndiansDiabetes2)
sum(is.na(PimaIndiansDiabetes2))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["pregnant"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["glucose"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["pressure"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["triceps"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["insulin"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["mass"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["pedigree"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["age"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["diabetes"],"name":[9],"type":["fctr"],"align":["left"]}],"data":[{"1":"6","2":"148","3":"72","4":"35","5":"NA","6":"33.6","7":"0.627","8":"50","9":"pos","_rn_":"1"},{"1":"1","2":"85","3":"66","4":"29","5":"NA","6":"26.6","7":"0.351","8":"31","9":"neg","_rn_":"2"},{"1":"8","2":"183","3":"64","4":"NA","5":"NA","6":"23.3","7":"0.672","8":"32","9":"pos","_rn_":"3"},{"1":"1","2":"89","3":"66","4":"23","5":"94","6":"28.1","7":"0.167","8":"21","9":"neg","_rn_":"4"},{"1":"0","2":"137","3":"40","4":"35","5":"168","6":"43.1","7":"2.288","8":"33","9":"pos","_rn_":"5"},{"1":"5","2":"116","3":"74","4":"NA","5":"NA","6":"25.6","7":"0.201","8":"30","9":"neg","_rn_":"6"},{"1":"3","2":"78","3":"50","4":"32","5":"88","6":"31.0","7":"0.248","8":"26","9":"pos","_rn_":"7"},{"1":"10","2":"115","3":"NA","4":"NA","5":"NA","6":"35.3","7":"0.134","8":"29","9":"neg","_rn_":"8"},{"1":"2","2":"197","3":"70","4":"45","5":"543","6":"30.5","7":"0.158","8":"53","9":"pos","_rn_":"9"},{"1":"8","2":"125","3":"96","4":"NA","5":"NA","6":"NA","7":"0.232","8":"54","9":"pos","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre><code>## [1] 768   9
## [1] 652</code></pre>
<p>Here we have a real world problem therefore lots of missing values, NA, are present in the data set. If we just delete individuals with missing values, we will not only end up with only 392 individuals but more importantly introduce a bias (e.g. gender bias if we delete individuals with missing age, which are usually women), therefore a list-wise delettion is not a recommended way of handling missing data. Here for simplicity we will use mean imputation strategy, i.e. will replace each NA value with mean value of the respective variable.</p>
<pre class="r"><code>phen&lt;-colnames(PimaIndiansDiabetes2)[2:6]
for(i in phen)
{
  PimaIndiansDiabetes2[,i][is.na(PimaIndiansDiabetes2[,i])==TRUE]&lt;-mean(PimaIndiansDiabetes2[,i],na.rm=TRUE)
}
head(PimaIndiansDiabetes2,10)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["pregnant"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["glucose"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["pressure"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["triceps"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["insulin"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["mass"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["pedigree"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["age"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["diabetes"],"name":[9],"type":["fctr"],"align":["left"]}],"data":[{"1":"6","2":"148","3":"72.00000","4":"35.00000","5":"155.5482","6":"33.60000","7":"0.627","8":"50","9":"pos","_rn_":"1"},{"1":"1","2":"85","3":"66.00000","4":"29.00000","5":"155.5482","6":"26.60000","7":"0.351","8":"31","9":"neg","_rn_":"2"},{"1":"8","2":"183","3":"64.00000","4":"29.15342","5":"155.5482","6":"23.30000","7":"0.672","8":"32","9":"pos","_rn_":"3"},{"1":"1","2":"89","3":"66.00000","4":"23.00000","5":"94.0000","6":"28.10000","7":"0.167","8":"21","9":"neg","_rn_":"4"},{"1":"0","2":"137","3":"40.00000","4":"35.00000","5":"168.0000","6":"43.10000","7":"2.288","8":"33","9":"pos","_rn_":"5"},{"1":"5","2":"116","3":"74.00000","4":"29.15342","5":"155.5482","6":"25.60000","7":"0.201","8":"30","9":"neg","_rn_":"6"},{"1":"3","2":"78","3":"50.00000","4":"32.00000","5":"88.0000","6":"31.00000","7":"0.248","8":"26","9":"pos","_rn_":"7"},{"1":"10","2":"115","3":"72.40518","4":"29.15342","5":"155.5482","6":"35.30000","7":"0.134","8":"29","9":"neg","_rn_":"8"},{"1":"2","2":"197","3":"70.00000","4":"45.00000","5":"543.0000","6":"30.50000","7":"0.158","8":"53","9":"pos","_rn_":"9"},{"1":"8","2":"125","3":"96.00000","4":"29.15342","5":"155.5482","6":"32.45746","7":"0.232","8":"54","9":"pos","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Further, we define Y and X variables and perform mean centering and scaling of the variables in the X matrix in order to take into account that they all have very different scale and variation.</p>
<pre class="r"><code>Y&lt;-factor(PimaIndiansDiabetes2$diabetes)
X&lt;-scale(PimaIndiansDiabetes2[,1:8],center=TRUE,scale=TRUE)
scaled_PimaIndiansDiabetes2&lt;-data.frame(X,diabetes=Y)
scaled_PimaIndiansDiabetes2$random&lt;-rnorm(dim(scaled_PimaIndiansDiabetes2)[1])
head(scaled_PimaIndiansDiabetes2)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["pregnant"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["glucose"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["pressure"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["triceps"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["insulin"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["mass"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["pedigree"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["age"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["diabetes"],"name":[9],"type":["fctr"],"align":["left"]},{"label":["random"],"name":[10],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.6395305","2":"0.8645447","3":"-0.03349641","4":"0.66506871","5":"0.0000000","6":"0.1661834","7":"0.4681869","8":"1.42506672","9":"pos","10":"-0.7746771","_rn_":"1"},{"1":"-0.8443348","2":"-1.2053760","3":"-0.52951396","4":"-0.01745201","5":"0.0000000","6":"-0.8519760","7":"-0.3648230","8":"-0.19054773","9":"neg","10":"0.6767719","_rn_":"2"},{"1":"1.2330766","2":"2.0145006","3":"-0.69485314","4":"0.00000000","5":"0.0000000","6":"-1.3319654","7":"0.6040037","8":"-0.10551539","9":"pos","10":"1.0827720","_rn_":"3"},{"1":"-0.8443348","2":"-1.0739525","3":"-0.52951396","4":"-0.69997273","5":"-0.7239170","6":"-0.6337989","7":"-0.9201630","8":"-1.04087112","9":"neg","10":"0.9164680","_rn_":"4"},{"1":"-1.1411079","2":"0.5031299","3":"-2.67892334","4":"0.66506871","5":"0.1464551","6":"1.5479712","7":"5.4813370","8":"-0.02048305","9":"pos","10":"0.4456567","_rn_":"5"},{"1":"0.3427574","2":"-0.1868436","3":"0.13184277","4":"0.00000000","5":"0.0000000","6":"-0.9974273","7":"-0.8175458","8":"-0.27558007","9":"neg","10":"0.8268205","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Note that we have also added an artificial random variable (white noise) as a new feature for controlling how ML algorithms can distinguish between signal and noise. We will check this variable later when we look at feature importances from the algorithms.</p>
<p>Now according to Machine Learning phylosophy we are going to split the data set into training and test data sets. The former will be used for tuning hyperparameters and training the model while the latter will be used only once at the very end for ultimate evaluation of the models accuracy:</p>
<pre class="r"><code>set.seed(1)
train&lt;-scaled_PimaIndiansDiabetes2[sample(1:dim(scaled_PimaIndiansDiabetes2)[1],0.7*dim(scaled_PimaIndiansDiabetes2)[1]),]
head(train)
dim(train)
test&lt;-scaled_PimaIndiansDiabetes2[!rownames(scaled_PimaIndiansDiabetes2)%in%rownames(train),]
head(test)
dim(test)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["pregnant"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["glucose"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["pressure"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["triceps"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["insulin"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["mass"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["pedigree"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["age"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["diabetes"],"name":[9],"type":["fctr"],"align":["left"]},{"label":["random"],"name":[10],"type":["dbl"],"align":["right"]}],"data":[{"1":"-0.2507887","2":"-0.0225642","3":"-1.6868882","4":"0.0000000","5":"0.0000000","6":"0.5152667","7":"-1.0408890","8":"-0.7007418","9":"pos","10":"-1.73597423","_rn_":"679"},{"1":"-0.8443348","2":"-0.1539877","3":"1.2892171","4":"-0.5862193","5":"-0.1240659","6":"0.2970897","7":"-0.2078791","8":"0.5747433","9":"pos","10":"0.31417912","_rn_":"129"},{"1":"-0.5475618","2":"-1.2382319","3":"-1.8522274","4":"-0.6999727","5":"-0.9356291","6":"-0.2992609","7":"1.4973766","8":"-1.0408711","9":"neg","10":"0.02567157","_rn_":"509"},{"1":"-0.8443348","2":"0.7331211","3":"0.7931995","4":"1.2338360","5":"0.0000000","6":"1.2861588","7":"0.4078238","8":"-0.4456447","9":"neg","10":"0.78369235","_rn_":"471"},{"1":"3.0137150","2":"-0.7125378","3":"0.4625211","4":"-0.4724658","5":"0.3346437","6":"0.6025375","7":"-0.1807158","8":"1.0849374","9":"pos","10":"0.70226627","_rn_":"299"},{"1":"-0.5475618","2":"0.7988329","3":"0.0000000","4":"0.0000000","5":"0.0000000","6":"-0.7210698","7":"-0.6998379","8":"-0.4456447","9":"pos","10":"1.13756449","_rn_":"270"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre><code>## [1] 537  10</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["pregnant"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["glucose"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["pressure"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["triceps"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["insulin"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["mass"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["pedigree"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["age"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["diabetes"],"name":[9],"type":["fctr"],"align":["left"]},{"label":["random"],"name":[10],"type":["dbl"],"align":["right"]}],"data":[{"1":"-0.5475618","2":"2.4744830","3":"-0.1988356","4":"1.8026032","5":"4.5571245","6":"-0.2847157","7":"-0.9473263","8":"1.68016374","9":"pos","10":"1.32559247","_rn_":"9"},{"1":"1.2330766","2":"0.1088593","3":"1.9505738","4":"0.0000000","5":"0.0000000","6":"0.0000000","7":"-0.7239831","8":"1.76519608","9":"pos","10":"1.93102959","_rn_":"10"},{"1":"1.8266227","2":"1.5216623","3":"0.1318428","4":"0.0000000","5":"0.0000000","6":"0.8061694","7":"0.1965532","8":"0.06454929","9":"pos","10":"-0.84018560","_rn_":"12"},{"1":"1.8266227","2":"0.5688417","3":"0.6278603","4":"0.0000000","5":"0.0000000","6":"-0.7792503","7":"2.9249624","8":"2.02029310","9":"neg","10":"0.65042430","_rn_":"13"},{"1":"-0.8443348","2":"2.2116359","3":"-1.0255315","4":"-0.6999727","5":"8.1209454","6":"-0.3428963","7":"-0.2229699","8":"2.19035777","9":"pos","10":"-0.97143640","_rn_":"14"},{"1":"-1.1411079","2":"-0.1211318","3":"0.9585387","4":"2.0301101","5":"0.8756858","6":"1.9406898","7":"0.2388073","8":"-0.19054773","9":"pos","10":"0.02683526","_rn_":"17"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre><code>## [1] 231  10</code></pre>
<p>Now let us start training different Machine Learning algorithms such as Linear Descriminant Analysis (LDA), Desicion Tree (CART), K-Nearest Neighbors (KNN), Support Vectir Machines (SVM), Random Forest (RF) by applying K-fold cross-validation in order to tune hyperparameters of each algorithm. As a metric for optimization of hyperparameters we will use ROC which is a balance between sensitivity and specificity of the algorithms.</p>
<pre class="r"><code>library(&quot;caret&quot;)
set.seed(1)
control&lt;-trainControl(method=&quot;repeatedcv&quot;, number=10, savePredictions=T, repeats=5, classProbs=T, summaryFunction=twoClassSummary)

metric &lt;- &quot;ROC&quot;

fit.lda &lt;- train(diabetes~., data=train, method=&quot;lda&quot;, metric=metric, trControl=control, na.action=na.omit)
fit.cart &lt;- train(diabetes~., data=train, method=&quot;rpart&quot;, metric=metric, trControl=control, na.action=na.omit)
fit.knn &lt;- train(diabetes~., data=train, method=&quot;knn&quot;, metric=metric, trControl=control,na.action=na.omit)
fit.svm &lt;- train(diabetes~., data=train, method=&quot;svmRadial&quot;, metric=metric, trControl=control,na.action=na.omit)
fit.rf &lt;- train(diabetes~., data=train, method=&quot;rf&quot;, metric=metric, trControl=control, na.action=na.omit)
results &lt;- resamples(list(lda=fit.lda, cart=fit.cart, knn=fit.knn, svm=fit.svm, rf=fit.rf))
summary(results)
dotplot(results)</code></pre>
<pre><code>## 
## Call:
## summary.resamples(object = results)
## 
## Models: lda, cart, knn, svm, rf 
## Number of resamples: 50 
## 
## ROC 
##           Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&#39;s
## lda  0.6852941 0.7897794 0.8160217 0.8177914 0.8540441 0.9117647    0
## cart 0.5232198 0.6315015 0.6761223 0.6770922 0.7346169 0.7972136    0
## knn  0.6501548 0.7623259 0.7999790 0.8002395 0.8467879 0.9073529    0
## svm  0.7191176 0.7898994 0.8348297 0.8290690 0.8644156 0.9349845    0
## rf   0.6764706 0.7664183 0.8005998 0.8065597 0.8448529 0.9164087    0
## 
## Sens 
##           Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&#39;s
## lda  0.7352941 0.8235294 0.8550420 0.8591597 0.8857143 0.9705882    0
## cart 0.6000000 0.7426471 0.7941176 0.7947563 0.8529412 1.0000000    0
## knn  0.6764706 0.7720588 0.8407563 0.8264538 0.8823529 0.9411765    0
## svm  0.6764706 0.8235294 0.8529412 0.8551092 0.9117647 0.9705882    0
## rf   0.6764706 0.7720588 0.8235294 0.8224202 0.8560924 0.9705882    0
## 
## Spec 
##           Min.   1st Qu.    Median      Mean   3rd Qu.      Max. NA&#39;s
## lda  0.3500000 0.5000000 0.5500000 0.5665789 0.6315789 0.8000000    0
## cart 0.2105263 0.4052632 0.5263158 0.5156316 0.6236842 0.8947368    0
## knn  0.3684211 0.5500000 0.6000000 0.5975789 0.6756579 0.7894737    0
## svm  0.3500000 0.5000000 0.5894737 0.5748421 0.6315789 0.8947368    0
## rf   0.3500000 0.5263158 0.5789474 0.5788947 0.6500000 0.8421053    0</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/Train%20Algorithms-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>Looking at the mean ROC values for each algorithm we conclude that Linear Descriminant Analysis (LDA) performed slightly better than the other algorithms, so for our particular data set there is no need to run non-linear algorithms like Random Forest (RF) or Support Vector Machines (SVM) with non-linear Radial Base Function (RBF) kernel. Diabetics and Non-Diabetics seem to be linearly separable.</p>
<p>Now we will summarize the best model:</p>
<pre class="r"><code>best_model&lt;-get(paste0(&quot;fit.&quot;,names(summary(results)$statistics$ROC[,4])[as.numeric(summary(results)$statistics$ROC[,4])==max(summary(results)$statistics$ROC[,4])]))
print(best_model)</code></pre>
<pre><code>## Support Vector Machines with Radial Basis Function Kernel 
## 
## 537 samples
##   9 predictor
##   2 classes: &#39;neg&#39;, &#39;pos&#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 483, 483, 484, 483, 483, 483, ... 
## Resampling results across tuning parameters:
## 
##   C     ROC        Sens       Spec     
##   0.25  0.8290690  0.8551092  0.5748421
##   0.50  0.8270896  0.8668403  0.5592632
##   1.00  0.8222837  0.8692605  0.5377368
## 
## Tuning parameter &#39;sigma&#39; was held constant at a value of 0.09306208
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were sigma = 0.09306208 and C = 0.25.</code></pre>
<p>Let us now have a look at the ranking of the predictors by their importance:</p>
<pre class="r"><code>varImp(best_model)
my_features&lt;-varImp(best_model)$importance$pos
names(my_features)&lt;-rownames(varImp(best_model)$importance)
barplot(sort(my_features,decreasing=TRUE),ylab=&quot;FEATURE IMPORTANCE&quot;,col=&quot;darkred&quot;)</code></pre>
<pre><code>## ROC curve variable importance
## 
##          Importance
## glucose      100.00
## mass          62.21
## age           59.06
## insulin       42.98
## triceps       40.19
## pregnant      36.40
## pedigree      29.21
## pressure      27.73
## random         0.00</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-17-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>We can see that glucose, age, mass and insulin seems to be the most important predictors which is what we would also expect based on our knowledge about Type 2 Diabetes (T2D). Note, that the random noise variable got the lowest rank. What does it mean? It implies that it is safe to add “garbage” variables (which do not have anything to do with the phenotype of interest) into the data set without doing a manual curation/selection of the variables. This is because ML will recognize them and filter out automatically. So no need to rely on your hypothesis and intuition when building a data set for analysis. ML can discriminate signal from noise very well providing large enough data set.</p>
<p>Now let us use the test data set and make predictions about disease status (positive or negative) of the individuals in the test data:</p>
<pre class="r"><code>predictions &lt;- predict(best_model, test)
confusionMatrix(predictions, test$diabetes)</code></pre>
<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction neg pos
##        neg 141  39
##        pos  18  33
##                                           
##                Accuracy : 0.7532          
##                  95% CI : (0.6924, 0.8074)
##     No Information Rate : 0.6883          
##     P-Value [Acc &gt; NIR] : 0.018172        
##                                           
##                   Kappa : 0.3751          
##                                           
##  Mcnemar&#39;s Test P-Value : 0.008071        
##                                           
##             Sensitivity : 0.8868          
##             Specificity : 0.4583          
##          Pos Pred Value : 0.7833          
##          Neg Pred Value : 0.6471          
##              Prevalence : 0.6883          
##          Detection Rate : 0.6104          
##    Detection Prevalence : 0.7792          
##       Balanced Accuracy : 0.6726          
##                                           
##        &#39;Positive&#39; Class : neg             
## </code></pre>
<p>The accuracy of prediction is 75% which is quite high.</p>
<p>To compare different algorithms by their performance on the test data set let us plot ROC curves for each algorithm:</p>
<pre class="r"><code>library(&quot;pROC&quot;)
predictions &lt;- predict(best_model, test, type=&quot;prob&quot;)
my_ROC&lt;-roc(test$diabetes, predictions[,&quot;pos&quot;])
tpr&lt;-my_ROC$sensitivities
fpr&lt;-1-my_ROC$specificities
plot(tpr~fpr,type=&#39;l&#39;, ylab=&quot;TRUE POSITIVE RATE&quot;, xlab=&quot;FALSE POSITIVE RATE&quot;,col=&quot;red&quot;)
lines(c(0,1),c(0,1))

colors_vector&lt;-c(&quot;blue&quot;,&quot;green&quot;,&quot;magenta&quot;,&quot;orange&quot;)
names_vector&lt;-names(summary(results)$statistics$ROC[,4])
names_vector&lt;-names_vector[-which(names_vector==names(summary(results)$statistics$ROC[,4])[as.numeric(summary(results)$statistics$ROC[,4])==max(summary(results)$statistics$ROC[,4])])]
for(i in 1:length(names_vector))
{
  current_model&lt;-get(paste0(&quot;fit.&quot;,names_vector[i]))
  current_predictions &lt;- predict(current_model, test, type=&quot;prob&quot;)
  current_ROC&lt;-roc(test$diabetes, current_predictions[,&quot;pos&quot;])
  current_tpr&lt;-current_ROC$sensitivities
  current_fpr&lt;-1-current_ROC$specificities
  lines(current_tpr~current_fpr,type=&#39;l&#39;,col=colors_vector[i])
}
legend(&quot;bottomright&quot;, c(&quot;LDA&quot;,&quot;CART&quot;,&quot;KNN&quot;,&quot;SVM&quot;,&quot;RF&quot;), fill=c(&quot;red&quot;,colors_vector), inset=0.02)</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-19-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>We conclude that all algorithms except maybe CART perform with comparable accuracy.</p>
</div>
<div id="artificial-neural-networks-ann" class="section level1">
<h1><span class="header-section-number">6</span> Artificial Neural Networks (ANN)</h1>
<p>We have seen in the previous section that diabetics and non-diabetics seem to be linearly separable. So in this particular case it does not make much sense to run a Neural Network on this data set because one uses the full power of ANN when there are non-linear relationships in the data, i.e. classes are non-linearly separable. However for demonstration purpose let us run a Neural Network with 1 hidden layer and 3 hidden neurons:</p>
<pre class="r"><code>library(&quot;neuralnet&quot;)
set.seed(12345)
train$diabetes&lt;-as.numeric(train$diabetes)
test$diabetes&lt;-as.numeric(test$diabetes)
NN = neuralnet(diabetes ~ pregnant + glucose + pressure + triceps + insulin + mass + pedigree + age, data=train, hidden = 3 , linear.output = TRUE, act.fct=&quot;logistic&quot; )</code></pre>
<pre class="r"><code>plot(NN, rep=&quot;best&quot;)</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/unnamed-chunk-22-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>Here we visualize the architecture of the ANN in order to be able to monitor weights and biases. We can also take the trained model and check its performance on the test data set, i.e. make predictions and produce a Confusion Matrix summarizing how many times (per class) our prediction was correct and how many times it was wrong.</p>
<pre class="r"><code>prediction &lt;- neuralnet::compute(NN, test[,1:8])
cm&lt;-table(test$diabetes,round(prediction$net.result[,1]))
cm</code></pre>
<pre><code>##    
##       1   2
##   1 141  18
##   2  31  41</code></pre>
<p>To calculate the accuracy of the prediction we need to take the sum of diagonal elements (trace) of the Confusion Matrix, which show how many times we made a correct prediction per class, and divide it by the total number of samples in the test data set.</p>
<pre class="r"><code>library(&quot;psych&quot;)
tr(cm)/sum(cm)</code></pre>
<pre><code>## [1] 0.7878788</code></pre>
<p>So far so good, but why did we select only one hidden layer and 3 hidden neurons and not 2 or 5 or 20? Well, one hidden layer is very often enough to address majority of real-world problems unless heavily non-linear data is analyzed. The number of hidden neurons is actually a hyperparameter which can be found via Cross-Validation (CV).</p>
<pre class="r"><code>set.seed(1)
train_and_validate&lt;-scaled_PimaIndiansDiabetes2[sample(1:dim(scaled_PimaIndiansDiabetes2)[1],0.7*dim(scaled_PimaIndiansDiabetes2)[1]),]
train_and_validate$diabetes&lt;-as.numeric(train_and_validate$diabetes)
test&lt;-scaled_PimaIndiansDiabetes2[!rownames(scaled_PimaIndiansDiabetes2)%in%rownames(train_and_validate),]
test$diabetes&lt;-as.numeric(test$diabetes)

N_neurons&lt;-10
N_cv&lt;-10
accuracy&lt;-vector(length=N_neurons)
for(i in 1:N_neurons)
{
  print(paste0(&quot;NUMBER OF HIDDEN NEURONS: &quot;,i))
  accuracy_cv&lt;-vector(length=N_cv)
  for(j in 1:N_cv)
  {
    validate&lt;-train_and_validate[sample(1:dim(train_and_validate)[1],0.2*dim(train_and_validate)[1]),]
    train&lt;-train_and_validate[!rownames(train_and_validate)%in%rownames(validate),]

    NN = neuralnet(diabetes ~ pregnant + glucose + pressure + triceps + insulin + mass + pedigree + age, data=train, hidden = i , linear.output = TRUE, act.fct=&quot;logistic&quot;)
    prediction &lt;- neuralnet::compute(NN, validate[,1:8])
    corrected_prediction&lt;-round(prediction$net.result[,1])
    corrected_prediction[corrected_prediction==0]&lt;-1
    corrected_prediction[corrected_prediction==3]&lt;-2
    cm&lt;-table(validate$diabetes,corrected_prediction)
    accuracy_cv[j]&lt;-tr(cm)/sum(cm)
  }
  accuracy[i]&lt;-mean(accuracy_cv,na.rm=TRUE)
}
names(accuracy)&lt;-seq(1:N_neurons)
accuracy
plot(accuracy~seq(1:N_neurons),type=&#39;o&#39;,xlab=&quot;Number of Hidden Neurons&quot;,ylab=&quot;Accuracy&quot;,main=&quot;Cross-Validation Accuracy&quot;)</code></pre>
<pre><code>## [1] &quot;NUMBER OF HIDDEN NEURONS: 1&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 2&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 3&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 4&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 5&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 6&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 7&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 8&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 9&quot;
## [1] &quot;NUMBER OF HIDDEN NEURONS: 10&quot;
##         1         2         3         4         5         6         7 
## 0.7598131 0.7570093 0.7504673 0.7130841 0.7252336 0.7214953 0.7074766 
##         8         9        10 
## 0.7102804 0.6766355 0.6822430</code></pre>
<p><img src="Lab_MachineLearning_files/figure-html/NeuralNet%20CV-1.svg" width="960" style="display: block; margin: auto auto auto 0;" /></p>
<p>It seems that the accuracy of Cross-Validation (CV) peaks at 1 neurons. Let us use this optimal number of neurons for the final test of accuracy at the test/unseen data set.</p>
<pre class="r"><code>NN = neuralnet(diabetes ~ pregnant + glucose + pressure + triceps + insulin + mass + pedigree + age, data=train_and_validate, hidden = as.numeric(names(accuracy)[accuracy==max(accuracy)]) , linear.output = TRUE, act.fct=&quot;logistic&quot;)
prediction &lt;- neuralnet::compute(NN, test[,1:8])
cm&lt;-table(test$diabetes,round(prediction$net.result[,1]))
cm
accuracy&lt;-tr(cm)/sum(cm)
accuracy</code></pre>
<pre><code>##    
##       1   2
##   1 134  25
##   2  25  47
## [1] 0.7835498</code></pre>
<p>We can see that 1) the accuracy on the test data set was not as good as on the training and validation data sets, 2) overall ANN does not seem to perform better than Random Forest (RF) or Linear Discriminant Analysis (LDA). Further tuning and optimizations are needed, we have tuned only one hyperparameter. Welcome to the real world! Artificial Neural Networks (ANN) have many hyperparameters, they are typically optimized via so-called Grid Search when each combination of hyperparameters is tested. This is a very expensive operation and very often needs GPU computing available. Nevertheless, hyperparameter tuning might lead to a drammatic increase in performance of Neural Networks which is not really the case for traditional Machine Learning algorithms. This represents a huge flexibility and potential of ANNs.</p>
<!-- --------------------- Do not edit this and below ---------------------- -->
</div>
<div id="session-info" class="section level1">
<h1><span class="header-section-number">7</span> Session info</h1>
<pre><code>## R version 3.6.0 (2019-04-26)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 14.04.6 LTS
## 
## Matrix products: default
## BLAS:   /usr/local/lib/R/lib/libRblas.so
## LAPACK: /usr/local/lib/R/lib/libRlapack.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=sv_SE.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=sv_SE.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=sv_SE.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=sv_SE.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] psych_1.8.12     neuralnet_1.44.2 pROC_1.15.0      caret_6.0-84    
##  [5] ggplot2_3.1.1    lattice_0.20-38  mlbench_2.1-1    captioner_2.2.3 
##  [9] bookdown_0.11    knitr_1.23      
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.1          lubridate_1.7.4     class_7.3-15       
##  [4] assertthat_0.2.1    digest_0.6.19       ipred_0.9-9        
##  [7] foreach_1.4.4       R6_2.4.0            plyr_1.8.4         
## [10] stats4_3.6.0        evaluate_0.14       e1071_1.7-2        
## [13] pillar_1.4.1        rlang_0.3.4         lazyeval_0.2.2     
## [16] data.table_1.12.2   kernlab_0.9-27      rpart_4.1-15       
## [19] Matrix_1.2-17       rmarkdown_1.13      splines_3.6.0      
## [22] foreign_0.8-71      gower_0.2.1         stringr_1.4.0      
## [25] munsell_0.5.0       compiler_3.6.0      xfun_0.7           
## [28] pkgconfig_2.0.2     mnormt_1.5-5        htmltools_0.3.6    
## [31] nnet_7.3-12         tidyselect_0.2.5    tibble_2.1.3       
## [34] prodlim_2018.04.18  codetools_0.2-16    randomForest_4.6-14
## [37] crayon_1.3.4        dplyr_0.8.1         withr_2.1.2        
## [40] MASS_7.3-51.4       recipes_0.1.5       ModelMetrics_1.2.2 
## [43] grid_3.6.0          nlme_3.1-139        jsonlite_1.6       
## [46] gtable_0.2.0        magrittr_1.5        scales_1.0.0       
## [49] stringi_1.4.3       reshape2_1.4.3      timeDate_3043.102  
## [52] generics_0.0.2      lava_1.6.5          iterators_1.0.9    
## [55] tools_3.6.0         glue_1.3.1          purrr_0.3.2        
## [58] parallel_3.6.0      survival_2.44-1.1   yaml_2.2.0         
## [61] colorspace_1.4-1</code></pre>
<p style="text-align: left; font-size: small;">
Built on: <i class="fa fa-calendar" aria-hidden="true"></i> 15-jun-2019 at <i class="fa fa-clock-o" aria-hidden="true"></i> 21:39:24.
</p>
<hr/>
<div style="padding-bottom: 1.5em">
<p><span style="float:left; vertical-align:middle">
<b>2019</b> • <a href="https://www.scilifelab.se/">SciLifeLab</a> • <a href="https://nbis.se/">NBIS</a> • <a href="https://nbisweden.github.io/workshop-RaukR-1906/">RaukR</a>
</span>
<span style="float:right; vertical-align:middle">
<span class="footericon" style="padding-right:4px; padding-left:4px">
<a href="https://nbisweden.github.io/workshop-RaukR-1806/"><img src="assets/icons8-globe-26.png" alt="website" border="0" style="height:15px"></a>
</span>
<span class="footericon" style="padding-right:4px; padding-left:4px">
<a href="https://twitter.com/hashtag/RaukR?src=hash"><img src="assets/icons8-twitter-26.png" alt="twitter" border="0" style="height:15px"></a>
</span>
</span></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
